# librex-ast

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

**librex-ast** is a feature-rich, PCRE2-compatible regular expression engine written in modern C. It provides a complete pipeline for compiling regex patterns into an efficient internal bytecode representation and executing them against subject strings using a backtracking NFA-style virtual machine.

Originally an AST parser, the library has evolved into a complete engine designed for correctness, feature-completeness, and PCRE2 compatibility. It serves as an excellent foundation for building custom tools, educational software, or for anyone interested in the internals of modern regex engines.

---

### ⚠️ Project Status: Advanced & Experimental

This library is a comprehensive implementation of a modern regex engine, capable of passing a large compatibility test suite. However, before using it in a production environment, please be aware of the following:

*   **Not Yet Performance-Tuned:** The VM implementation is focused on correctness and feature support. It has not yet been optimized for high-throughput production workloads and may be significantly slower than mature libraries like PCRE2.
*   **Simplified Unicode Properties:** The `\p{...}` property support is comprehensive but uses a simplified, non-exhaustive set of Unicode data. A production-ready version would require data generated from the full Unicode Character Database (UCD).

Contributions to address these points are highly welcome!

---

### Key Features

*   **PCRE2-Compatible Engine:** A complete engine that compiles patterns and matches strings, not just a parser.
*   **Two-Stage Compilation:**
    1.  **Parser:** A robust recursive-descent parser builds a detailed Abstract Syntax Tree (AST) from the pattern.
    2.  **Compiler:** The AST is then compiled into a compact and efficient bytecode format.
*   **Backtracking NFA Virtual Machine:** The engine uses a custom VM to execute the bytecode, providing powerful and correct matching behavior.
*   **Extensive Syntax Support:** Implements a wide array of PCRE2/Perl constructs, including advanced assertions, conditionals, and subroutines.
*   **Structured Error Reporting:** The compile function provides a detailed `regex_err` object with an error code, message, and the exact position of the error in the pattern.
*   **Pluggable Memory Allocators:** The entire library can be configured to use custom `malloc`, `realloc`, and `free` functions for specialized memory environments.
*   **Clean, Opaque API:** The compiled pattern is managed through an opaque `regex_compiled*` handle, hiding internal complexity.
*   **Unicode-Aware:** Correctly parses UTF-8 patterns, Unicode escape sequences (`\x{...}`), and Unicode properties (`\p{L}`).
*   **Zero Dependencies:** Written in pure C99 with no external library dependencies.

---

### Architecture Overview

The engine operates in three distinct stages:

1.  **Parsing (`regex-parser.c`)**: The input pattern string is parsed into an Abstract Syntax Tree (AST). This tree represents the logical structure of the regular expression. This stage validates syntax and reports errors.
2.  **Compilation (`regex-match.c`)**: The AST is traversed by a compiler which emits a linear sequence of bytecode instructions. This bytecode is a low-level representation of the matching logic, optimized for the VM.
3.  **Execution (`regex-match.c`)**: The generated bytecode is executed by a lightweight, stack-based virtual machine (VM). The VM performs the actual matching against the subject string using a backtracking NFA algorithm.

---

### Usage Example

Here is a simple example of how to compile a pattern, execute a match, and inspect the results.

```c
#include <stdio.h>
#include <stdlib.h>
#include "regex-parser.h"

int main(void) {
    const char* pattern = "(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})";
    const char* subject = "The date is 2023-11-28.";

    regex_err error = {0};
    
    // 1. Compile the pattern
    regex_compiled* rx = regex_compile(pattern, 0, &error);

    if (!rx) {
        fprintf(stderr, "Failed to compile pattern at position %d: %s\n", 
                error.pos, error.msg);
        return 1;
    }
    
    printf("Successfully compiled pattern: \"%s\"\n", pattern);

    // 2. Execute the match
    regex_match_result result = {0};
    int match_status = regex_match(rx, subject, strlen(subject), &result);

    if (match_status > 0) {
        printf("Match found from index %d to %d!\n", result.match_start, result.match_end);
        printf("  - Full match: '%.*s'\n", 
               (result.match_end - result.match_start), 
               subject + result.match_start);

        for (int i = 0; i < result.capture_count; i++) {
            if (result.capture_starts[i] != -1) {
                printf("  - Group %d: '%.*s'\n", i + 1,
                       (result.capture_ends[i] - result.capture_starts[i]),
                       subject + result.capture_starts[i]);
            }
        }
        
        // 3. Free the match result
        regex_free_match_result(&result, NULL);

    } else if (match_status == 0) {
        printf("No match found.\n");
    } else {
        // A negative return value from regex_match is an execution error
        fprintf(stderr, "Execution error: %s\n", regex_error_message(-match_status));
    }

    // 4. Free the compiled regex object
    regex_free(rx);

    return 0;
}
```

### API Reference

#### Core Structures

*   `regex_compiled`: An opaque pointer representing a compiled regular expression.
*   `regex_err`: A struct containing detailed error information (`code`, `pos`, `line`, `col`, `msg`).
*   `regex_match_result`: A struct containing the results of a successful match, including overall match bounds and an array of capture group bounds.
*   `regex_allocator`: A struct allowing you to provide custom memory allocation functions.

#### Main Functions

*   `regex_compiled* regex_compile(const char* pattern, uint32_t flags, regex_err* error)`
    Compiles a null-terminated `pattern` string using standard library allocators. On success, returns an opaque `regex_compiled*` handle. On failure, returns `NULL` and populates the `error` struct.

*   `regex_compiled* regex_compile_with_allocator(...)`
    Same as `regex_compile` but uses a custom `regex_allocator`.

*   `void regex_free(regex_compiled* rx)`
    Frees all memory associated with a compiled regex handle.

*   `int regex_match(regex_compiled* rx, const char* subject, size_t subject_len, regex_match_result* result)`
    Executes a compiled regex `rx` against a `subject` string.
    *   Returns `1` on a successful match and populates the `result` struct.
    *   Returns `0` if no match is found.
    *   Returns a negative `REGEX_ERR_*` code on a runtime error (e.g., recursion limit).

*   `void regex_free_match_result(regex_match_result* result, const regex_allocator* allocator)`
    Frees the capture group arrays within a `regex_match_result` struct. Pass `NULL` for the allocator to use the standard library `free`.

#### Utility Functions

*   `const char* regex_error_message(int error_code)`
    Returns a static, human-readable string for a given `REGEX_ERR_*` code.

*   `void print_regex_ast(const regex_compiled* rx)`
    A debugging utility to print a human-readable representation of the internal AST to standard output.

#### Compilation Flags

*   `REG_IGNORECASE`: Perform case-insensitive matching.
*   `REG_MULTILINE`: `^` and `$` match the start/end of lines, not just the start/end of the string.
*   `REG_SINGLELINE`: `.` (dot) metacharacter matches all characters, including newlines.
*   `REG_EXTENDED`: Ignore unescaped whitespace and comments starting with `#`.
*   `REG_UNGREEDY`: Invert the greediness of quantifiers (e.g., `*` becomes lazy, `*?` becomes greedy).

---

### Supported Regex Syntax

The engine supports a wide subset of PCRE2/Perl syntax.

#### Basic Elements
- Literal characters (full Unicode support)
- `.` (dot metacharacter, respects `REG_SINGLELINE`)
- Character classes `[abc]`, `[^abc]`, `[a-z]`
- Pre-defined classes: `\d`, `\D`, `\w`, `\W`, `\s`, `\S`
- Anchors: `^`, `$`, `\A`, `\z`, `\b` (word boundary), `\B`

#### Quantifiers
- Greedy: `*`, `+`, `?`, `{n,m}`
- Lazy (non-greedy): `*?`, `+?`, `??`, `{n,m}?`
- Possessive: `*+`, `++`, `?+`, `{n,m}+`

#### Groups
- Capturing groups: `(...)`
- Non-capturing groups: `(?:...)`
- Named capturing groups: `(?<name>...)`
- Atomic groups: `(?>...)`
- Branch-reset groups: `(?|...)`

#### Assertions
- Positive Lookahead: `(?=...)`
- Negative Lookahead: `(?!...)`
- Positive Lookbehind: `(?<=...)` (fixed-length only)
- Negative Lookbehind: `(?<!...)` (fixed-length only)

#### Backreferences & Subroutines
- Numbered backreferences: `\1`, `\2`, etc.
- Named backreferences: `\k<name>`
- Numbered subroutine calls: `(?1)`, `(?2)`, etc.
al
- Named subroutine calls: `(?&name)`
- Full pattern recursion: `(?R)`

#### Conditionals
- Numeric condition: `(?(1)yes|no)`
- Named condition: `(?(<name>)yes|no)`
- Assertion condition: `(?(?=...)yes|no)`

#### Modifiers & Unicode
- Inline flags: `(?i)`, `(?-m)`
- Scoped flags: `(?i:...)`
- Unicode properties: `\p{L}`, `\P{Sc}`
- Unicode escapes: `\x{...}`, `\u....`
- POSIX character classes: `[[:alpha:]]`, `[[:digit:]]`, etc.

#### Other
- Comments: `(?#...)`
- Quoted sequences: `\Q...\E`

---

### Building

The project has no external dependencies. You can compile the library and its test suite using a C99 compiler like GCC or Clang.

```bash
# Compile the engine with the test harness
gcc -o test_engine regex-parser.c regex-match.c regex-unicode.c regex-test.c -Wall -Wextra -std=c99

# Run the test suite
./test_engine
```

---

### Roadmap & Contributing

This project is an excellent platform for exploring regex engine design. Contributions are welcome to make it more robust and performant. High-priority areas include:

-   [ ] **Performance Optimization:** Profile and optimize the VM loop, reduce memory allocations during matching, and implement bytecode optimizations (e.g., peephole optimizations).
-   [ ] **Full Unicode Support:** Integrate code generation scripts to build comprehensive property, script, and character-folding tables from the official Unicode Character Database (UCD).
-   [ ] **JIT Compilation:** Explore adding a Just-In-Time (JIT) compiler backend (e.g., targeting x86-64) for performance-critical patterns.
-   [ ] **CI & Testing:** Expand the test suite for more comprehensive coverage and set up continuous integration checks.

Please feel free to open an issue to discuss a new feature or submit a pull request.

### License

This project is licensed under the **MIT License**.

### Author

Mounir IDRASSI <mounir.idrassi@amcrypto.jp>